# 第四课 — CMake 使用与 Linux 下 C++ 编译

本课目标：
- 了解 CMake 基本概念与常用指令
- 掌握在 Linux 下用 CMake 构建、测试与安装 C++ 项目
- 了解典型的 C++ 代码库目录结构
> 推荐git clone下来PX4源码库然后参考源码库的相应文件学习
---

## 1 CMake 简介

CMake 是一个跨平台的开源构建系统生成器。它通过编写 `CMakeLists.txt` 描述项目构建规则，生成平台本地的构建文件（如 Makefile、Ninja 文件或 Visual Studio 工程）。推荐使用“现代 CMake”（基于目标 `target` 的方式）而非旧式全局命令。

优势：跨平台、支持外部依赖查找、支持 out-of-source builds、与 CI/打包工具（CTest、CPack）集成良好。

---

## 2 CMakeLists常见概念与命令

- `cmake_minimum_required(VERSION 3.16)`：指定最低 CMake 版本。
- `project(MyProj VERSION 1.0 LANGUAGES CXX)`：声明项目名与语言。
- `add_executable(name files...)`：添加可执行目标。
- `add_library(name STATIC|SHARED|OBJECT files...)`：添加库目标。
- `target_include_directories(target PUBLIC|PRIVATE|INTERFACE path...)`：为目标设置头文件搜索路径（现代方式）。
- `target_link_libraries(target PUBLIC|PRIVATE|INTERFACE lib...)`：为目标设置链接依赖。
- `add_subdirectory(dir)`：包含子目录的 `CMakeLists.txt`。
- `find_package(PkgName [version] REQUIRED)`：查找已安装的包（如 Boost、Threads）。
- `option(NAME "desc" ON|OFF)`：声明配置选项。
- `configure_file(in out @ONLY)`：生成配置头或脚本。

---

## 3 简单示例：单目录项目

项目结构：

- src/main.cpp
- CMakeLists.txt

根目录 `CMakeLists.txt` 示例：

```
cmake_minimum_required(VERSION 3.16)
project(helloworld VERSION 0.1 LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
add_executable(hello src/main.cpp)
```

构建（在 Linux）：

```bash
mkdir -p build && cd build
cmake -DCMAKE_BUILD_TYPE=Release ..
cmake --build . -- -j$(nproc)
```
构建结果存在build文件夹下
运行：`./hello`。

---

## 4 多目录项目与现代目标用法

示例项目布局：

- CMakeLists.txt  （根）
- src/
  - CMakeLists.txt
  - lib.cpp
  - lib.h
- app/
  - CMakeLists.txt
  - main.cpp
- include/
  - mylib/   （放公共头）

根 `CMakeLists.txt`：

```
cmake_minimum_required(VERSION 3.16)
project(MyProject VERSION 0.1 LANGUAGES CXX)
add_subdirectory(src)
add_subdirectory(app)
```

`src/CMakeLists.txt`：

```
add_library(mylib STATIC lib.cpp)
target_include_directories(mylib
  PUBLIC ${CMAKE_SOURCE_DIR}/include
)
target_compile_features(mylib PUBLIC cxx_std_17)
```

`app/CMakeLists.txt`：

```
add_executable(myapp main.cpp)
target_link_libraries(myapp PRIVATE mylib)
```

要点：
- 使用 `target_*` 系列函数传递接口（包含路径、编译选项、链接依赖），避免全局命令污染。
- `PRIVATE`、`PUBLIC`、`INTERFACE` 的语义：
  - `PRIVATE`：只影响当前目标。 
  - `PUBLIC`：同时影响当前目标和使用它的下游目标（传递）。
  - `INTERFACE`：不影响当前目标，仅传递给使用它的下游目标。

---

## 5 查找与使用第三方库

- 优先使用 `find_package`（结合 package-config 或 CMake 配置包）。
- 对于 header-only 或未安装库，可使用 `FetchContent` 或将外部源放在 `third_party/` 并通过 `add_subdirectory` 引入。

示例：使用 Threads

```
find_package(Threads REQUIRED)
target_link_libraries(myapp PRIVATE Threads::Threads)
```

若第三方提供 CMake config（如 FooConfig.cmake 或 FooTargets.cmake），`find_package(Foo REQUIRED)` 会导入目标 `Foo::Foo`，直接 `target_link_libraries`。

---

## 6 构建变种与缓存变量

- 推荐使用 out-of-source build（即在 `build/` 目录运行 `cmake ..`）。
- 常用缓存变量：`CMAKE_BUILD_TYPE`（Debug/Release/RelWithDebInfo）、`CMAKE_INSTALL_PREFIX`、`CMAKE_CXX_COMPILER`。
- 使用 `-D` 传入变量：`cmake -DCMAKE_BUILD_TYPE=Debug ..`。

查看缓存：`cmake -LAH`。

---

## 7 安装、测试与打包

- 安装：在 `CMakeLists.txt` 中使用 `install(TARGETS ... DESTINATION ...)` 与 `install(FILES ...)`，然后执行 `cmake --install . --prefix /desired/prefix` 或 `make install`。
- 测试：使用 `enable_testing()` 与 `add_test()`，运行 `ctest` 或 `ctest -V`。
- 打包：使用 `CPack`（生成 tar.gz、DEB、RPM、ZIP 等），在 `CMakeLists.txt` 中配置并调用 `cpack`。

示例：启用测试

```
enable_testing()
add_executable(tests test.cpp)
add_test(NAME mytests COMMAND tests)
```

---

## 8 进阶主题（简要）

- 导出与配置包（Export & Config）：用于安装后让其他项目通过 `find_package` 使用你的库。
- 自定义模块：把常用查找脚本放到 `cmake/Modules/`，并使用 `list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake")`。
- 交叉编译：配置 toolchain 文件并用 `cmake -DCMAKE_TOOLCHAIN_FILE=path/to/toolchain.cmake ..`。
- 使用 `target_compile_options` / `target_compile_definitions` 控制编译器选项和宏。

---

## 9 Linux 下 C++ 代码库的典型构成与约定

推荐目录布局（简洁且常见）：

- `CMakeLists.txt`（根）: 项目入口，添加子目录与全局选项
- `src/`：实现源码（`.cpp` 文件）
- `include/`：公共头文件（安装时暴露给用户）
- `tests/`：单元测试代码
- `examples/`：示例程序
- `third_party/`：第三方库源码（或子模块）
- `tools/` 或 `scripts/`：构建/开发脚本（Python/Bash）
- `docs/`：文档
- `cmake/`：自定义 CMake 模块或工具链文件
- `build/`：构建输出（通常被 .gitignore 忽略）

设计与约定：
- 公共 API 的头文件放在 `include/<proj>/`，源代码中的私有头放在 `src/` 或 `src/include/`。
- 使用命名空间与路径对应：`include/mylib/foo.h` -> `mylib::foo`（命名约定视团队而定）。
- 使用 `README.md`、`CONTRIBUTING.md` 和 `LICENSE` 提供项目信息与贡献指南。

---

## 10 静态库 vs 共享库 vs 头文件库

- 静态库（`.a`）：链接时合并到可执行文件，部署简单但文件大；Linux 下通常用 `add_library(name STATIC ...)`。
- 共享库（`.so`）：动态链接，支持运行时替换与节省磁盘空间，使用 `add_library(name SHARED ...)`。
- 头文件库：无编译产物，直接包含头实现（template-heavy 或 header-only 库）。

安装例子（根 CMake 中）：

```
install(TARGETS mylib EXPORT mylibTargets
  ARCHIVE DESTINATION lib
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION bin)
install(DIRECTORY include/ DESTINATION include)
install(EXPORT mylibTargets
  FILE mylibTargets.cmake
  NAMESPACE mylib::
  DESTINATION lib/cmake/mylib)
```

---

## 11 常见问题与调试技巧

- 如果找不到库，先检查 `CMAKE_PREFIX_PATH` 或 `PKG_CONFIG_PATH`。可用 `cmake -DCMAKE_PREFIX_PATH=/opt/mylib ..`。
- 使用 `message(STATUS "var=${var}")` 在 CMake 配置阶段打印变量。
- 若链接阶段报符号未定义，检查目标的 `INTERFACE`/`PUBLIC` 依赖传递是否正确。
- 对动态库运行时找不到符号，检查 `LD_LIBRARY_PATH` 或安装 `rpath`（`target_link_options`/`INSTALL_RPATH`）。

---
